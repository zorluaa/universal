local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()



local Window = Rayfield:CreateWindow({
    Name = "Void.lua┃ Universal ",
    Icon = 0, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
    LoadingTitle = "The Best Universal Script",
    LoadingSubtitle = "by zor / xx1xx1x1x1",
    Theme = "Default", -- Check https://docs.sirius.menu/rayfield/configuration/themes
 
    DisableRayfieldPrompts = false,
    DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface
 
    ConfigurationSaving = {
       Enabled = true,
       FolderName = nil, -- Create a custom folder for your hub/game
       FileName = "Void.lua"
    },
 
    Discord = {
       Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
       Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ABCD would be ABCD
       RememberJoins = true -- Set this to false to make them join the discord every time they load it up
    },
 
    KeySystem = true, -- Set this to true to use our key system
    KeySettings = {
       Title = "Void.lua System ",
       Subtitle = "Void Key System",
       Note = "Contact xx1xx1x1x1 on discord", -- Use this to tell the user how to get a key
       FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
       SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
       GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
       Key = {"VoidUniversal"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
    }
 })







 local Tab1 = Window:CreateTab("Aiming", 4483362458) -- Title, Image
 local Tab2 = Window:CreateTab("MISC", 4483362458) -- Title, Image
 local Tab3 = Window:CreateTab("ESP", 4483362458) -- Title, Image


 



 local Section1 = Tab1:CreateSection("Aiming")
 local Section2 = Tab2:CreateSection("MISC")
 local Section3 = Tab3:CreateSection("ESP")


















 local UIS = game:GetService("UserInputService")
 local RunService = game:GetService("RunService")
 local Players = game:GetService("Players")
 local LocalPlayer = Players.LocalPlayer
 local Mouse = LocalPlayer:GetMouse()
 
 local MouseLocked = false
 local TargetPart = "Head" -- Default target part
 local PredictionX, PredictionY, PredictionZ = 10, 10, 10
 
 -- Toggle Mouse Lock
 local Toggle = Tab1:CreateToggle({
     Name = "Mouse Lock",
     CurrentValue = false,
     Flag = "MouseLockToggle",
     Callback = function(Value)
         MouseLocked = Value
         if not MouseLocked then
             UIS.MouseBehavior = Enum.MouseBehavior.Default
         end
     end,
 })
 
 -- Dropdown to select target body part
 local Dropdown = Tab1:CreateDropdown({
     Name = "Lock-On Target",
     Options = {"Head", "Torso", "Legs"},
     CurrentOption = {"Head"},
     MultipleOptions = false,
     Flag = "LockOnDropdown",
     Callback = function(Option)
         TargetPart = Option[1] -- Update target part
     end,
 })
 
 -- Keybind to toggle mouse lock
 local Keybind = Tab1:CreateKeybind({
     Name = "Mouse Lock Keybind",
     CurrentKeybind = "Q",
     HoldToInteract = false,
     Flag = "MouseLockKeybind",
     Callback = function()
         MouseLocked = not MouseLocked
         if not MouseLocked then
             UIS.MouseBehavior = Enum.MouseBehavior.Default
         end
         print("Mouse lock toggled:", MouseLocked)
     end,
 })
 
 -- Prediction sliders
 local SliderX = Tab1:CreateSlider({
     Name = "Prediction X",
     Range = {0, 100},
     Increment = 1,
     Suffix = "%",
     CurrentValue = PredictionX,
     Flag = "PredictionSliderX",
     Callback = function(Value)
         PredictionX = Value
     end,
 })
 
 local SliderY = Tab1:CreateSlider({
     Name = "Prediction Y",
     Range = {0, 100},
     Increment = 1,
     Suffix = "%",
     CurrentValue = PredictionY,
     Flag = "PredictionSliderY",
     Callback = function(Value)
         PredictionY = Value
     end,
 })
 
 local SliderZ = Tab1:CreateSlider({
     Name = "Prediction Z",
     Range = {0, 100},
     Increment = 1,
     Suffix = "%",
     CurrentValue = PredictionZ,
     Flag = "PredictionSliderZ",
     Callback = function(Value)
         PredictionZ = Value
     end,
 })
 
 -- Function to get the closest player
 local function GetClosestPlayer()
     local ClosestPlayer = nil
     local ShortestDistance = math.huge
     
     for _, Player in pairs(Players:GetPlayers()) do
         if Player ~= LocalPlayer and Player.Character and Player.Character:FindFirstChild(TargetPart) then
             local Target = Player.Character[TargetPart]
             local Distance = (Target.Position - LocalPlayer.Character.Head.Position).Magnitude
             if Distance < ShortestDistance then
                 ClosestPlayer = Target
                 ShortestDistance = Distance
             end
         end
     end
     
     return ClosestPlayer
 end
 
 -- Update aim position
 RunService.RenderStepped:Connect(function()
     if MouseLocked then
         local Target = GetClosestPlayer()
         if Target then
             local predictedX = Target.Position.X + (PredictionX / 100)
             local predictedY = Target.Position.Y + (PredictionY / 100)
             local predictedZ = Target.Position.Z + (PredictionZ / 100)
             Mouse.Hit = CFrame.new(predictedX, predictedY, predictedZ)
             UIS.MouseBehavior = Enum.MouseBehavior.LockCenter
         else
             UIS.MouseBehavior = Enum.MouseBehavior.Default
         end
     end
 end)
 




-- Toggle for NoClip
local NoClipEnabled = false

local NoClipToggle = Tab2:CreateToggle({
    Name = "NoClip",
    CurrentValue = false,
    Flag = "NoClipToggle", -- Unique flag
    Callback = function(Value)
        NoClipEnabled = Value
        print("NoClip:", Value)

        -- Activate NoClip
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()

        game:GetService("RunService").Stepped:Connect(function()
            if NoClipEnabled and character then
                for _, part in pairs(character:GetDescendants()) do
                    if part:IsA("BasePart") and part.CanCollide then
                        part.CanCollide = false
                    end
                end
            end
        end)
    end,
})








-- Slider to adjust Walk Speed
local WalkSpeedSlider = Tab2:CreateSlider({
    Name = "Walk Speed",
    Range = {16, 399}, -- Min and max range for Walk Speed
    Increment = 1, -- Increment by 1
    Suffix = "WS", -- Add a suffix for the slider
    CurrentValue = 16, -- Default value
    Flag = "WalkSpeedSlider", -- Unique flag
    Callback = function(Value)
        -- Update the character's walk speed
        local player = game.Players.LocalPlayer
        if player.Character and player.Character:FindFirstChildOfClass("Humanoid") then
            player.Character:FindFirstChildOfClass("Humanoid").WalkSpeed = Value
            print("Walk Speed set to:", Value)
        end
    end,
})


-- Slider to adjust Jump Power
local JumpPowerSlider = Tab2:CreateSlider({
    Name = "Jump Power",
    Range = {16, 399}, -- Min and max range for Jump Power
    Increment = 1, -- Increment by 1
    Suffix = "JP", -- Add a suffix for the slider
    CurrentValue = 50, -- Default value
    Flag = "JumpPowerSlider", -- Unique flag
    Callback = function(Value)
        -- Update the character's jump power
        local player = game.Players.LocalPlayer
        if player.Character and player.Character:FindFirstChildOfClass("Humanoid") then
            player.Character:FindFirstChildOfClass("Humanoid").JumpPower = Value
            print("Jump Power set to:", Value)
        end
    end,
})






-- Unified ESP Script (Box, Skeleton, Name)
-- Author: Blissful#4992 (Refactored for optimization and dynamic updates)

--// Configuration
local settings = {
    BoxESP = {
        Enabled = false,
        Color = Color3.fromRGB(255, 255, 255),
        Thickness = 2,
    },
    SkeletonESP = {
        Enabled = false,
        Color = Color3.fromRGB(255, 255, 255),
    },
    NameESP = {
        Enabled = false,
        Color = Color3.fromRGB(255, 255, 255),
        Size = 15,
        Transparency = 1,
        AutoScale = true,
    },
}

local players = game:GetService("Players")
local runService = game:GetService("RunService")
local camera = game.Workspace.CurrentCamera
local localPlayer = players.LocalPlayer
local espObjects = {} -- Table to track ESP objects per player

-- Utility Functions
local function createDrawing(type, properties)
    local obj = Drawing.new(type)
    for prop, value in pairs(properties) do
        obj[prop] = value
    end
    return obj
end

local function createESPObjectsForPlayer(player)
    local espData = {
        Box = {
            Top = createDrawing("Line", {Thickness = settings.BoxESP.Thickness, Color = settings.BoxESP.Color}),
            Bottom = createDrawing("Line", {Thickness = settings.BoxESP.Thickness, Color = settings.BoxESP.Color}),
            Left = createDrawing("Line", {Thickness = settings.BoxESP.Thickness, Color = settings.BoxESP.Color}),
            Right = createDrawing("Line", {Thickness = settings.BoxESP.Thickness, Color = settings.BoxESP.Color}),
        },
        Skeleton = {}, -- Skeleton logic placeholder if implemented
        Name = createDrawing("Text", {
            Size = settings.NameESP.Size,
            Transparency = settings.NameESP.Transparency,
            Center = true,
            Color = settings.NameESP.Color,
        }),
    }
    espObjects[player] = espData
end

local function cleanupESPForPlayer(player)
    if espObjects[player] then
        for _, obj in pairs(espObjects[player].Box) do
            obj:Remove()
        end
        for _, obj in pairs(espObjects[player].Skeleton) do
            obj:Remove()
        end
        if espObjects[player].Name then
            espObjects[player].Name:Remove()
        end
        espObjects[player] = nil
    end
end

-- Update Logic
local function updateESP()
    for player, data in pairs(espObjects) do
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character:FindFirstChild("Humanoid") then
            local humanoid = player.Character:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health > 0 then
                local hrp = player.Character.HumanoidRootPart
                local screenPos, onScreen = camera:WorldToViewportPoint(hrp.Position)
    
                if onScreen then
                    -- Update Box ESP
                    if settings.BoxESP.Enabled then
                        local head = player.Character:FindFirstChild("Head")
                        local scale = head and head.Size.Y / 2 or 1
                        local size = Vector3.new(2, 3, 0) * (scale * 2)
                        local topLeft = camera:WorldToViewportPoint((hrp.CFrame * CFrame.new(size.X, size.Y, 0)).Position)
                        local topRight = camera:WorldToViewportPoint((hrp.CFrame * CFrame.new(-size.X, size.Y, 0)).Position)
                        local bottomLeft = camera:WorldToViewportPoint((hrp.CFrame * CFrame.new(size.X, -size.Y, 0)).Position)
                        local bottomRight = camera:WorldToViewportPoint((hrp.CFrame * CFrame.new(-size.X, -size.Y, 0)).Position)
    
                        local box = data.Box
                        box.Top.From = Vector2.new(topLeft.X, topLeft.Y)
                        box.Top.To = Vector2.new(topRight.X, topRight.Y)
                        box.Bottom.From = Vector2.new(bottomLeft.X, bottomLeft.Y)
                        box.Bottom.To = Vector2.new(bottomRight.X, bottomRight.Y)
                        box.Left.From = Vector2.new(topLeft.X, topLeft.Y)
                        box.Left.To = Vector2.new(bottomLeft.X, bottomLeft.Y)
                        box.Right.From = Vector2.new(topRight.X, topRight.Y)
                        box.Right.To = Vector2.new(bottomRight.X, bottomRight.Y)
    
                        for _, line in pairs(box) do
                            line.Color = settings.BoxESP.Color
                            line.Thickness = settings.BoxESP.Thickness
                            line.Visible = true
                        end
                    else
                        for _, line in pairs(data.Box) do
                            line.Visible = false
                        end
                    end
    
                    -- Update Name ESP
                    if settings.NameESP.Enabled then
                        local nameTag = data.Name
                        nameTag.Text = player.Name
                        nameTag.Position = Vector2.new(screenPos.X, screenPos.Y - 30)
                        if settings.NameESP.AutoScale then
                            local distance = (camera.CFrame.Position - hrp.Position).Magnitude
                            nameTag.Size = math.clamp(1 / distance * 1000, 2, 30)
                        end
                        nameTag.Color = settings.NameESP.Color
                        nameTag.Visible = true
                    else
                        data.Name.Visible = false
                    end
    
                    -- Skeleton ESP update can be added here if implemented
    
                else
                    -- Hide ESP if off-screen
                    for _, line in pairs(data.Box) do
                        line.Visible = false
                    end
                    data.Name.Visible = false
                end
            else
                cleanupESPForPlayer(player)
            end
        else
            -- If the character isn’t fully loaded, hide the drawings.
            if data then
                for _, line in pairs(data.Box) do
                    line.Visible = false
                end
                if data.Name then
                    data.Name.Visible = false
                end
            end
        end
    end
end

-- Initialization
local function setupESPForPlayer(player)
    if player ~= localPlayer then
        -- Cleanup any previous ESP objects for this player to avoid duplicates/ghost drawings
        cleanupESPForPlayer(player)
        createESPObjectsForPlayer(player)
        if player.Character then
            player.CharacterAdded:Connect(function(character)
                wait(0.1) -- Allow time for character parts to load
                cleanupESPForPlayer(player)
                createESPObjectsForPlayer(player)
            end)
        else
            player.CharacterAdded:Connect(function(character)
                wait(0.1)
                cleanupESPForPlayer(player)
                createESPObjectsForPlayer(player)
            end)
        end
    end
end

local function setupESP()
    for _, player in ipairs(players:GetPlayers()) do
        setupESPForPlayer(player)
    end

    players.PlayerAdded:Connect(function(player)
        setupESPForPlayer(player)
    end)

    players.PlayerRemoving:Connect(function(player)
        cleanupESPForPlayer(player)
    end)

    runService.RenderStepped:Connect(updateESP)
end

-- GUI Integration
-- Example: Replace Tab5 with your GUI library implementation
Tab3:CreateToggle({
    Name = "Box ESP",
    Flag = "BoxESP_Toggle",
    Default = false,
    Callback = function(state)
        settings.BoxESP.Enabled = state
    end,
})

Tab3:CreateColorPicker({
    Name = "Box ESP Color",
    Color = settings.BoxESP.Color,
    Flag = "BoxESP_ColorPicker",
    Callback = function(color)
        settings.BoxESP.Color = color
    end,
})

Tab3:CreateToggle({
    Name = "Name ESP",
    Flag = "NameESP_Toggle",
    Default = false,
    Callback = function(state)
        settings.NameESP.Enabled = state
    end,
})

Tab3:CreateColorPicker({
    Name = "Name ESP Color",
    Color = settings.NameESP.Color,
    Flag = "NameESP_ColorPicker",
    Callback = function(color)
        settings.NameESP.Color = color
    end,
})

-- Run the ESP setup
setupESP()

